<!DOCTYPE html>  <!--CTRL + Shift + P: Para abrir el buscador de VS Code, escribir 'terminal'
                     para crear una nueva y nos dirijimos a Git Bash para cambiar la terminal que viene por 
                     defecto con VS Code. Git Bash está diseñado para trabajar con Git.                     
                    
                   Click Derecho en el lateral izquierdo de archivos y seleccionar: "Reveal in File Explorer"
                            esto sirve para arrastrar el index.html a nuestro navegador y ver nuestro avance.
                     -->
                
                <!-- Lista de Comandos -->
                <!-- pwd = "print working directory": Muestra la ruta completa del directorio en el que nos
                                                      encontramos actualmente.
                     
                     ls = "list": Lista el contenido del directorio actual, (archivos del lateral izquierdo
                                  en el directorio de trabajo) archivos y carpetas y lo muestra por consola.
                                  
                     ls -la = Muestra todos los archivos y  directorios, incluidos los ocultos en nuestro             
                              directorio actual. (Útil en caso de que el comando anterior "ls" no los muestre)    

                     git init = Inicializa un nuevo repositorio de Git, (el repositorio es una carpeta en donde
                                Git maneja todas las versiones de un proyecto. Contiene además todos los archivos
                                de nuestro proyecto, así como un subdirectorio .git que almacena toda la informa-
                                ción necesaria para gestionar las versiones del proyecto.) Este comando crea un
                                nuevo subdirectorio llamado .git en el directorio (carpeta) actual.
                    
                              - Utilidades de git init:
                                   
                                   1.- Crear un nuevo repositorio vacío: Al comenzar un nuevo proyecto utilizamos
                                       git init para crear un repositorio desde 0.
                                    
                                   2.- Convertir un proyecto existente: Si ya tenemos un proyecto sin control de
                                       versiones, podemos convertirlo en un repositorio Git ejecutando git init
                                       en el directorio del proyecto.     
                     
                     git status = Muestra el estado actual del directorio de trabajo y del área de preparación
                                  (Staging Area = Cambios pendientes de ser confirmados) en un repositorio Git.

                                  Utilidades de git status:

                            1.- Archivos preparados para commit (1. Working Tree = Directorio de Trabajo
                                (Carpeta donde está nuestro proyecto) 2. Staging Area = Área de Preparación
                                3. Commited = "Comprometido", cambios que han sido guardados en el historial
                                   del repositorio.)

                    * Este comando es muy útil para tener una visión general de los cambios del proyecto antes
                       de realizar un commit, asegurándonos de no olvidarnos de añadir ningún archivo importante
                       o de preparar los cambios necesarios.
                     
                    * Untracked files (U): ficheros sin seguimiento (archivos no rastreados) existen en nuestro
                       directorio de trabajo pero sin ser añadidos aún al índice de Git (Staging Area). Esto
                       significa que Git no está siguiendo estos archivos, por lo tanto, no los icluirá en 
                       los commits a menos que los añadamos explícitamente.

                    git add (A): Añade los cambios en el directorio de trabajo al índice (Staging Area). Esto
                    prepara los archivos y cambios para ser incluidos en el próximo commit.

                    "M" = Esta letra presente en uno de nuestros archivos del proyecto quiere decir 
                          que hemos modificado un archivo que ya estaba siendo rastreado por Git.
                          Esto indica que el archivo a cambiado desde la última vez que se realizó
                          un commit, pero dichos cambios aún no han sido añadidos al área de prepa-
                          ración (Staging Area) para ser confirmados (Committed).

                    * Esta letra se muestra cuando ejecutamos el comando git status.
                    * Esto da una visión general de los archivos que han sido modificados, añadidos
                      o eliminados en nuestro repositorio.

                    git reset: Quita todos los archivos del Staging Area. (útil si agregamos sin querer to-
                               dos los archivos de nuestro proyecto al Staging Area)

                    *git reset bg65aj1 <- Colocar las iniciales del HASH del commit del que se desea reiniciar.

                    git reset --hard HEAD~1: Elimina el último commit realizado y apunta al commit anterior al actual
                                             (1 commit atrás).

                    * HEAD: Apunta al commit actual en el que se está trabajando.
                    * ~1: Apunta al commit anterior al actual.
                    * ~2: Apunta a 2 commits atrás del actual, y así sucesivamente.

                    git rm nombre_del_archivo: Elimina el archivo del índice de Git y del sistema de archivos.
                    
                    git restore nombre_del_archivo: Restaura el archivo a su estado en el último commit.

                    git restore --staged nombre_del_archivo: Elimina el archivo del área de preparación, pero mantiene
                                                             los cambios en el área de trabajo.

                    git merge: Se utiliza para combinar los cambios de una rama en otra. Es una forma de integrar el trabajo 
                               de diferentes ramas en una sola.

                    *Ejemplo: git checkout master
                              git merge feature

                     En el ejemplo anterior, primero cambiamos a la rama master y luego fusionamos los cambios de la rama 
                     feature en master.
                     
                     ¿Cuándo usar git merge?
                     Al integrar nuevas características: Cuando hemos terminado de trabajar en una nueva característica en 
                     una rama separada y queremos integrar esos cambios en la rama principal.

                    git push: Se utiliza para enviar los cambios que hemos realizado en nuestro repositorio local al 
                              repositorio remoto. Comparte nuestros cambios con otros colaboradores y nos asegura de que el
                              repositorio remoto esté actualizado con nuestro trabajo.

                    *Después de hacer un commit o varios utilizamos git push para enviar esos cambios al repositorio remoto.

                    git pull: Se utiliza para actualizar el repositorio local con los cambios más recientes del repositorio
                              remoto.

                    *Es una combinación de 2 comandos: git fetch (para descargar los cambios) y git merge (para fusionar 
                                                       esos cambios en tu rama actual). 
                                                       
                    ¿Cuándo usar git pull?
                    Mantener tu repositorio actualizado: Usamos git pull regularmente para asegurarnos de que nuestro 
                                                         repositorio local esté sincronizado con el repositorio remoto.                                                        

                    Colaboración en equipo: Si trabajamos en un equipo, git pull permite obtener los cambios realizados 
                                            por otros colaboradores y fusionarlos con nuestro trabajo.

                    git restore . Restaura todos los archivos en el árbol de trabajo a su estado en el último commit.

                    git restore --staged . Elimina todos los archivos del área de preparación, pero mantiene los cambios
                                           en el árbol de trabajo.
                    
                    rm nombre_del_archivo: Elimina el archivo solo del sistema de archivos.

                    git add . agrega todos los archivos del directorio actual. (Es en donde estamos ubicados).

                    git commit: Guarda todos los cambios del Staging Area en el repositorio local como un nuevo co-
                                mmit.

                    *Los commits no van directamente al repositorio remoto, se guardan en el local. (Nuestro equipo).
                    
                    git commit -m: Se utiliza para añadir un mensaje de commit, breve descripción de los cam-
                                   bios confirmados en el repositorio.

                    *Luego de esto agregar correo y nombre de desarrollador.

                    git checkout: Se utiliza para restaurar archivos, navegar por el historial
                                  de commits y cambiar entre ramas.

                    git checkout -b: se utiliza para crear una nueva rama y cambiar a ella en un solo paso. Es una combinación 
                    de 2 comandos: git branch (para crear una nueva rama) y git checkout (para cambiar a esa rama).

                    ¿Qué hace este comando? (git checkout -b feature) 
                     Crea una nueva rama: En este caso, se crea una nueva rama llamada feature.

                     *El nombre de la rama viene después de -b.

                     Cambia a la nueva rama: Después de crear la nueva rama, Git cambia automáticamente a esa rama, por lo 
                     que cualquier cambio que realicemos a partir de ese momento se aplicará a la nueva rama.

                    *Para volver a uno de los commits enviados, por ejemplo una versión en donde una parte del
                     código de un programa existe y otra en donde no, debebos escribir:
                     
                     git checkout 6db8ds <- Iniciales del HASH del commit.

                    git checkout master: Cambia nuestro directorio de trabajo a la rama master (predeterminada) la cual es
                                         la rama principal de un repositorio. Aquí se integran los cambios más importantes,
                                         estables y oficiales del proyecto.
                                                          
                    clear: Limpia la terminal. (Atajo: CTRL + L).
                                  
                                  Utilidades de git checkout:

                                   1.- git ckeckout <hash-del-commit>: Cambia el estado de
                                                                       nuestro repositorio de
                                                                       trabajo a un commit es-
                                        (Copiar y pegar las iniciales  pecífico. Esto es útil 
                                            del Hash del commit)       para ver cómo estaba el 
                                                                       proyecto en un momento
                                                                       anterior, así como tam-
                                                                       bién si necesitamos rea-
                                                                       lizar pruebas con una
                                                                       versión anterior del có-
                                                                       digo.

                    ¿Qué es el Hash de un Commit?

                    Es un identificador único que se genera automáticamente cada vez que se realiza
                    un commit. Es una cadena de caracteres alfanuméricos que se utiliza para identi-
                    ficar de manera única ese commit en el repositorio. 

                    Cada Hash es único, y permite a los desarrolladores navegar por el historial de 
                    cambios de un proyecto, facilitando la resolución de problemas.

                    git log: Ve el historial de commits de nuestro repositorio. Incluye detalles como el au-
                             tor, la fecha y el mensaje del commit. Para salir del git log presionar "q".

                           - Utilidades de git log:
                               
                              1.- Rastreo de Cambios: Facilita el seguimiento de qué cambios se hicieron, 
                                  cuándo y por quién.

                              2.- Resolución de Problemas: Ayuda a identificar cuándo y dónde se introdujeron 
                                  errores.

                              3.- Colaboración: Mejora la comunicación y la colaboración en equipos al propor-
                                  cionar un historial claro de los cambios.
                                  
                    git log --graph --oneline: Permite visualizar el historial de commits en nuestro repositorio de Git de
                                               manera concisa y gráfica.

                    * --graph: Añade una representación gráfica de las ramas y fusiones en el historial.
                    * --oneline: Muestra cada commit en una sola línea, lo que hace que en el historial sea más fácil de leer.

                    ¿Qué es detached HEAD? (Detached = aislado)

                    Es cuando el puntero (HEAD) apunta directamente a un commit específico en lugar de apuntar a una rama.
                    Esto significa que estamos trabajando en un estado donde los cambios no están asociados a ninguna rama.
                    
                    *Si estamos en un último commit y hacemos un checkout con el HASH de ese commit siempre
                     estaremos en detached HEAD, donde los cambios no se aplicarán porque no estarán asociados
                     a ninguna rama. Para evitar esto, hacer git checkout "nombre de la rama" en este caso el
                     nombre de la rama es "master". Esto nos devuelve al último commit que hemos hecho.

                    ¿Qué es el HEAD?

                    Puntero que indica la referencia actual en la que estamos trabajando, normalmente, el HEAD 
                    apunta al último commit de la rama (HEAD -> master) en la que nos encontramos en lugar de a 
                    la rama como tal.
                    

                    Utilidades de detached HEAD:

                    Trabajar en este estado es útil en varias situaciones:

                    1.- Experimientación: Probar cambios sin afectar ninguna rama existente. Si decidimos que los cambios
                                          son útiles, podemos crear una nueva rama desde el estado actual y guardar nuestros
                                          cambios ahí.

                    2.- Revisión del Historial: Revisar el estado de un proyecto en cualquier commit anterior sin cambiar
                                                nuestra rama actual. Esto es útil para depurar o para entender cómo funcio-
                                                naba o se comportaba nuestro código en un punto específico en el tiempo.
                                                
                    3.- Construcción y Pruebas: Construir y probar versiones específicas del código sin necesidad de crear
                                                ramas temporales.

                    4.- Aplicación de Parches: Aplicar parches o cambios temporales para ver cómo afectan el código antes de
                                               decidir si deben ser incorporados permanentemente.

                    Problemas / Errores Comunes:

                        1.- "Author identity unknown
                         *** Please tell me who you are. 
                         Run

                            git config --global user.email "you@example.com"
                            git config --global user.name "Your Name" to set your account's default identity.
                           
                        Omit --global to set the identity only in this repository.
                        fatal: unable to auto-detect email address"
                    <---------------------------------------------------------------------------------------
                        Explicación: Este error ocurre porque Git no tiene configurada nuestra identidad de 
                        usuario, lo cual es necesario para registrar quién realiza los commits.
                              
                        Git necesita saber quienes somos para poder asociar nuestros cambios con nuestro 
                        nombre y correo electrónico.
                        
                    Solución: Ingresar correo electrónico y nombre reales después del comando git config 
                             --global user.email "e-mail". (--global para que esta configuración se aplique
                             a todos los repositorios de nuestra máquina. Útil si siempre usamos el mismo
                             nombre y correo electrónico para todos nuestros proyectos).

                             * Sin --global: Para configurar la identidad solo para el repositorio actual,
                                             útil si usamos diferentes identidades para diferentes proyectos.
                    
                    Verificación: Para asegurarnos de que la configuración o cambios realizados se han apli-
                                  cado correctamente, utilizamos los comandos:

                                        git config --global -- list # Para configuración global.
                                        git config --list # Para configuración del repositorio actual.              
                                             
                                        * Working Tree = Directorio de Trabajo.
                    --> 
                                
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Overpass+Mono&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="style.css">
    <title>Blog Curso-Git</title>
</head>
<body>
    <nav>
                <ul>
                    <li><a href="#Home">Home</a></li>
                    <li><a href="#Posts">Posts</a></li>
                    <li><a href="#Ranking">Ranking</a></li>
                    <li><a href="#Contact">Contact</a></li>
                </ul>
            </nav>
    <div>
        <img src="img/logoGit.webp">
        <h1>Blog Curso-Git & GitHub</h1>
    </div>
    <div>
        Aquí irá la publicidad.
    </div>
    <div class="container" id="content">
        <h3>Posts del usuario {nombre del usuario}</h3>
        <div class="post">
            <h4>Título del post</h4>
            <p>Contenido del post</p>
            <br>
            <p><span>Usuario:</span>Comentario</p>
        </div>
        
    </div>
    <h1>Ranking de Videojuegos para PC 2023</h1>
<ul>
    <li>1. Cyberpunk 2077</li>
    <li>2. The Witcher 3: Wild Hunt</li>
    <li>3. Elden Ring</li>
    <li>4. Apex Legends</li>
    <li>5. Valorant</li>
    <li>6. Destiny 2</li>
    <li>7. Fortnite</li>
    <li>8. Dota 2</li>
    <li>9. League of Legends</li>
    <li>10. Minecraft</li>
</ul>
</body>
</html>

